#! /bin/bash
#
# git-fixup is a shortcut for committing staged changes as a fixup. The commit message starts with "fixup!" and ends
# with the last commit's message. This way it can be autosquashed during a rebase.
#
# While git-commit does include a --fixup=<commit> option, using it consecutively without getting commit messages with
# multiple "fixup!" entries is more tedious than it should to be.
#

readonly VERSION="0.1.0"

. git-commands-utils

#
# Commits all staged changes as an autosquashable fixup.
#
function fixup
{
    local use_commit="${1:-HEAD}"
    local message_body="$2"

    # get the last log message
    local last_commit_message=$(git show --no-patch --format="%s" "$use_commit")

    # if the last commit was a fixup, use that; else, prepend with fixup!
    local commit_message=
    if [[ "$last_commit_message" =~ ^fixup!.*$ ]]; then
        commit_message="$last_commit_message"
    else
        commit_message="fixup! $last_commit_message"
    fi

    if [[ -z "$message_body" ]]; then
        git commit --quiet -m "$commit_message"
    else
        git commit --quiet -m "$commit_message" -m "$message_body"
    fi
}

message_body=
while getopts ":hvb:-:" opt; do
    case $opt in
        -)
            case "${OPTARG}" in
                message_body)
                            message_body="${!OPTIND}"
                            OPTIND=$(( $OPTIND + 1 ))
                            ;;
                help)       show_help;;
                version)    show_version "$VERSION";;
                *)      error "Unimplemented option --${OPTARG}";;
            esac
            ;;
        b)  message_body="$OPTARG";;
        h)  show_help;;
        v)  show_version "$VERSION";;
        \?) error "Invalid option: -$OPTARG";;
        :)  error "Option -$OPTARG requires an argument.";;
        *)  error "Unimplemented option: -$OPTARG";;
    esac
done

fixup "${!OPTIND}" "$message_body"

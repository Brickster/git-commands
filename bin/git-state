#! /bin/bash

#
# A more concise and comprehensive version of `git status` and `git log` in one command.
#

. git-commands-utils

TEMP_FILE=$(mktemp "/tmp/git-state.XXXXXXXXXX")

#
# Echos a section of the state.
#
# The output can be echoed in pretty format or compact. Pretty format includes pre- and a- pended newlines
# as well as tabs starting every line. Compact doesn't include the extra newlines and tabs added during
# pretty printing.
#
# $1: the section title
# $2: the text to print
# $3: the format to print the text in (pretty/compact)
#
function echo_section
{
    title="$1"
    text="$2"
    print_format="$3"

    echo -e "# ${green}$title${nocolor}" >> "$TEMP_FILE"
    if [[ $print_format == "pretty" ]] && [[ ! -z "$text" ]]; then

        IFS=$'\n' read -rd '' -a text <<< "$text"
        tab="    "

        echo >> "$TEMP_FILE"
        count=${#text[@]}
        for ((i=0;i<count;i++)); do
            echo "$tab${text[i]}" >> "$TEMP_FILE"
        done
        echo >> "$TEMP_FILE"

    elif [[ $print_format == "pretty" ]]; then
        # there's no text but we still want some nicer formatting
        echo >> "$TEMP_FILE"
    elif [[ ! -z "$text" ]]; then
        echo -e "$text" >> "$TEMP_FILE"
    fi
}

function is_new_repository
{
    if [[ "$(git log --oneline -1 2>&1)" == "fatal: bad default revision 'HEAD'" ]]; then
        return 0
    else
        return 1
    fi
}

function only_default_branch
{
    branches=$(git branch --no-color)
    IFS=$'\n' read -rd '' -a branches <<< "$branches"

    if (( ${#branches[@]} > 1 )); then
        return 1
    fi

    default_branch=$(git settings -d "master" "git-state.branches.default")
    if [[ "${branches[0]}" == "* $default_branch" ]]; then
        return 0
    else
        return 1
    fi
}

green='\x1B[0;32m'
nocolor='\x1B[0m'

while getopts ":hpf:cCeELsSbBRtTl:r:-:" opt; do
    case $opt in
        -)
            case "${OPTARG}" in
                log)
                    log_count="${!OPTIND}"
                    OPTIND=$(( $OPTIND + 1 ))
                    show_log=true
                    ;;
                reflog)
                    reflog_count="${!OPTIND}"
                    OPTIND=$(( $OPTIND + 1 ))
                    show_reflog=true
                    ;;
                full-log)       log_count=-1;;
                no-log)         log_count=0;;
                full-reflog)    reflog_count=-1;;
                no-reflog)      reflog_count=0;;
                status)         show_status=true;;
                no-status)      show_status=false;;
                branches)       show_branches=true;;
                no-branches)    show_branches=false;;
                stashes)        show_stashes=true;;
                no-stashes)     show_stashes=false;;
                show-empty)     show_empty=true;;
                no-show-empty)  show_empty=false;;
                color)          color="always";;
                pretty)         print_format="pretty";;
                format)
                    print_format="${!OPTIND}"
                    OPTIND=$(( $OPTIND + 1 ))
                    ;;
                format=*)       print_format=${OPTARG#*=};;
                no-color)
                    color="never"
                    green=""
                    nocolor=""
                    ;;
                help)           show_help;;
                *)              error "Unimplemented option --${OPTARG}";;
            esac
            ;;
        c)  color="always";;
        C)
            color="never"
            green=""
            nocolor=""
            ;;
        e)  show_empty=true;;
        E)  show_empty=false;;
        l)
            log_count="$OPTARG"
            show_log=true
            ;;
        L)  show_log=false;;
        r)
            reflog_count="$OPTARG"
            show_reflog=true
            ;;
        R)  reflog_count=0;;
        s)  show_status=true;;
        S)  show_status=false;;
        b)  show_branches=true;;
        B)  show_branches=false;;
        t)  show_stashes=true;;
        T)  show_stashes=false;;
        p)  print_format="pretty";;
        f)  print_format="$OPTARG";;
        h)  show_help;;
        \?) error "Invalid option: -$OPTARG";;
        :)  error "Option -$OPTARG requires an argument.";;
        *)  error "Unimplemented option: -$OPTARG";;
    esac
done

# load unset values from config
show_log="${show_log:-"$(git settings -d true git-state.log.show)"}"
log_count="${log_count:-"$(git settings -d 10 git-state.log.count)"}"
show_reflog="${show_reflog:-"$(git settings -d true git-state.reflog.show)"}"
reflog_count="${reflog_count:-"$(git settings -d 5 git-state.reflog.count)"}"
show_status="${show_status:-"$(git settings -d true git-state.status.show)"}"
show_branches="${show_branches:-"$(git settings -d true git-state.branches.show)"}"
show_stashes="${show_stashes:-"$(git settings -d true git-state.stashes.show)"}"
show_empty="${show_empty:-"$(git settings -d false git-state.show-empty)"}"
print_format="${print_format:-$(git settings -d compact git-state.format)}"
color="${color:-$(git settings -d always color.ui)}"
show_only_default_branch="${show_only_default_branch:-$(git settings -d true git-state.branches.show-only-default)}"

if is_new_repository; then

    # make sure status will output ANSI codes
    # this must be done using config since status has no --color option
    status_color=$(git config color.status)
    git config color.status "$color"

    status_info=$(git status --short)
    if [[ -z "$status_info" ]]; then
        status_info="Initial commit"
    fi

    echo_section "status $nocolor(${green}master$nocolor)" "$status_info" "$print_format"

    # reset color.status to its original setting
    if [[ -z "$status_color" ]]; then
        git config --unset color.status

        # unset may leave an empty section, remove it if it is
        section_count=$(git settings print -c color)
        if (( $section_count == 0 )); then
            git config --remove-section color
        fi

    else
        git config color.status "$status_color"
    fi

    exit 0
fi

# status
if $show_status; then
    # make sure status will output ANSI codes
    # this must be done using config since status has no --color option
    status_color=$(git config color.status)
    git config color.status "$color"

    # get the --branch part of 'git status --short --branch'
    status_info=$(git status --short --branch)
    IFS=$'\n' read -rd '' -a status_info <<< "$status_info"
    title="${status_info[0]}"
    title="${title##"## "}"

    status_info=$(git status --short)

    # an extra $nocolor used to make color print in its own coloring
    echo_section "status $nocolor($title)" "$status_info" "$print_format"

    # reset color.status to its original setting
    if [[ -z "$status_color" ]]; then
        git config --unset color.status

        # unset may leave an empty section, remove it if it is
        section_count=$(git settings print -c color)
        if (( $section_count == 0 )); then
            git config --remove-section color
        fi

    else
        git config color.status "$status_color"
    fi
fi

if $show_log && (( $log_count != 0 )); then
    log_output=$(git log -n "$log_count" --oneline --color="$color")
    echo_section "log" "$log_output" "$print_format"
fi

# reflog
if $show_reflog && (( $reflog_count != 0 )); then
    reflog_output=$(git reflog -n "$reflog_count" --color="$color")
    echo_section "reflog" "$reflog_output" "$print_format"
fi

# branches
if $show_branches && ( $show_only_default_branch || ! only_default_branch ); then
    branch_output=$(git branch -v --color="$color")
    echo_section "branches" "$branch_output" "$print_format"
fi

# stashes
if $show_stashes && ( $show_empty || [[ ! -z $(git stash list) ]] ); then
    stash_output=$(git stash list --oneline --color="$color")
    echo_section "stashes" "$stash_output" "$print_format"
fi

terminal_lines=$(tput lines)
state_lines=$(wc -l < "$TEMP_FILE" | awk '{print $1}')

# if git-state is too long for the window, less it instead
if (( $terminal_lines >= ((state_lines + 1)) )); then
    cat "$TEMP_FILE"
else
    cat "$TEMP_FILE" | less -r
fi
rm "$TEMP_FILE"

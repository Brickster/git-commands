#! /usr/bin/env python

import argparse
import re

from ast import literal_eval
from subprocess import call, check_output, PIPE, Popen
from utils.messages import error
from utils.parse_actions import flag_as_value

class colors:
    green = "\x1B[0;32m"
    no_color = "\x1B[0m"


def print_section(title, text=None, format="compact"):
    """Print a section."""

    section = "# {}{}{}".format(colors.green, title, colors.no_color) + '\n'

    if format == "pretty" and text is not None and len(text) > 0:
        # pretty print
        section += '\n'
        text = text.splitlines()
        for line in text:
            section += "    " + line + '\n'
        section += '\n'
    elif format == 'pretty':
        # there's no text but we still want some nicer formatting
        section += '\n'
    elif format == 'compact':
        section += text
    else:
        error("unknown format '{}'".format(format))

    return section


def only_default_branch():
    """Determine whether the branches section only contains the default branch."""

    branches = check_output(['git', 'branch', '--no-color']).splitlines()

    if len(branches) > 1:
        return False

    default_branch = check_output(['git', 'settings', 'get', '-d', 'master', 'git-state.branches.default']).splitlines()[0]
    if re.match('\* {}'.format(default_branch), branches[0]) is not None:
        return True
    else:
        return False


def is_new_repository():
    """Determines whether a repository is empty."""

    log = Popen(['git', 'log', '--oneline', '-1'], stdout=PIPE, stderr=PIPE)
    log_out, log_err = log.communicate()

    return log_err != '' and log_err.splitlines()[0] == "fatal: bad default revision 'HEAD'"


def main():

    # status defaults
    default_show_status = literal_eval(check_output(['git', 'settings', 'get', '-d', 'True', 'git-state.status.show']))

    # log defaults
    show_log = literal_eval(check_output(['git', 'settings', 'get', '-d', 'True', 'git-state.log.show']))
    if show_log:
        default_log_count = literal_eval(check_output(['git', 'settings', 'get', '-d', '10', 'git-state.log.count']))
    else:
        default_log_count = 0

    # reflog defaults
    show_reflog = literal_eval(check_output(['git', 'settings', 'get', '-d', 'True', 'git-state.reflog.show']))
    if show_reflog:
        default_reflog_count = literal_eval(check_output(['git', 'settings', 'get', '-d', '5', 'git-state.reflog.count']))
    else:
        default_reflog_count = 0

    # branches defaults
    default_show_branches = literal_eval(check_output(['git', 'settings', 'get', '-d', 'True', 'git-state.branches.show']))

    # stashes defaults
    default_show_stashes = literal_eval(check_output(['git', 'settings', 'get', '-d', 'True', 'git-state.stashes.show']))

    # general defaults
    show_only_default_branch = literal_eval(check_output(['git', 'settings', 'get', '-d', 'True', 'git-state.branches.show-only-default']))
    default_show_empty = literal_eval(check_output(['git', 'settings', 'get', '-d', 'False', 'git-state.show-empty']))
    default_format = check_output(['git', 'settings', 'get', '-d', 'compact', 'git-state.format']).splitlines()[0]
    default_show_color = check_output(['git', 'settings', 'get', '-d', 'always', 'color.ui']).splitlines()[0]

    parser = argparse.ArgumentParser(
        prog="git state",
        version="git-state 0.2.0",
        description="view the state of the working tree"
    )

    # status
    status_group = parser.add_mutually_exclusive_group()
    status_group.add_argument("-s", "--status", help="", action="store_true", dest="show_status", default=default_show_status)
    status_group.add_argument("-S", "--no-status", help="", action="store_false", dest="show_status")

    # log
    log_group = parser.add_mutually_exclusive_group()
    log_group.add_argument("-l", "--log", help="", type=int, dest="log_count", metavar="<count>", default=default_log_count)
    log_group.add_argument("-L", "--no-log", help="", action=flag_as_value(0), dest="log_count", nargs=0)
    log_group.add_argument("--full-log", help="", action=flag_as_value(-1), dest="log_count", nargs=0)

    # reflog
    reflog_group = parser.add_mutually_exclusive_group()
    reflog_group.add_argument("-r", "--reflog", help="", type=int, dest="reflog_count", metavar="<count>", default=default_reflog_count)
    reflog_group.add_argument("-R", "--no-reflog", help="", action=flag_as_value(0), dest="reflog_count", nargs=0)
    reflog_group.add_argument("--full-reflog", help="", action=flag_as_value(-1), dest="reflog_count", nargs=0)

    # branches
    branches_group = parser.add_mutually_exclusive_group()
    branches_group.add_argument("-b", "--branches", help="", action="store_true", dest="show_branches", default=default_show_branches)
    branches_group.add_argument("-B", "--no-branches", help="", action="store_false", dest="show_branches")

    # stashes
    stashes_group = parser.add_mutually_exclusive_group()
    stashes_group.add_argument("-t", "--stashes", help="", action="store_true", dest="show_stashes", default=default_show_stashes)
    stashes_group.add_argument("-T", "--no-stashes", help="", action="store_false", dest="show_stashes")

    # general
    ## color
    color_group = parser.add_mutually_exclusive_group()
    color_group.add_argument("-c", "--color", help="always color output", action="store_true", dest="show_color", default=default_show_color)
    color_group.add_argument("-C", "--no-color", help="never color output", action="store_false", dest="show_color")
    ## format
    format_group = parser.add_mutually_exclusive_group()
    format_group.add_argument("-f", "--format", help="", choices=("pretty", "compact"), metavar="<format>", dest="format", default=default_format)
    format_group.add_argument("-p", "--pretty", help="", action=flag_as_value("pretty"), dest="format", nargs=0)
    ## show empty
    show_empty_group = parser.add_mutually_exclusive_group()
    show_empty_group.add_argument("-e", "--show-empty", help="", action="store_true", dest="show_empty", default=default_show_empty)
    show_empty_group.add_argument("-E", "--no-show-empty", help="", action="store_false", dest="show_empty")

    args = parser.parse_args()

    if args.show_color:
        color = "always"
    else:
        color = "never"
        colors.green = colors.no_color

    state = ''
    if is_new_repository():

        # make sure status will output ANSI codes
        # this must be done using config since status has no --color option
        status_color = Popen(['git', 'config', '--local', 'color.status'], stdout=PIPE, stderr=PIPE)
        status_color_out, status_color_err = status_color.communicate()
        call(['git', 'config', 'color.status', color])

        # check if status is empty
        status = check_output(['git', 'status', '--short'])
        if status == "":
            status = "Initial commit"

        title = 'status {}({}master{})'.format(colors.no_color, colors.green, colors.no_color)
        state += print_section(title, status, args.format)

        # reset color.status to its original setting
        if status_color_err == '':
            call(['git', 'config', '--unset', 'color.status'])

            # unset may leave an empty section, remove it if it is
            section_count = literal_eval(check_output(['git', 'settings', 'list', '--local', '--count', color]))
            if section_count == 0:
                call(['git', 'config', '--remove-section', 'color'])
        else:
            call(['git', 'config', 'color.status', color_status_out])

    else:
        if args.show_status:

            # make sure status will output ANSI codes
            # this must be done using config since status has no --color option
            status_color = Popen(['git', 'config', '--local', 'color.status'], stdout=PIPE, stderr=PIPE)
            status_color_out, status_color_err = status_color.communicate()
            call(['git', 'config', 'color.status', color])

            status = check_output(['git', 'status', '--short', '--untracked-files=all', '--branch']).splitlines()
            status_title = 'status {}({})'.format(colors.no_color ,status.pop(0).lstrip('# '))
            status = '\n'.join(status)
            state += print_section(status_title, status, args.format)

            # reset color.status to its original setting
            if status_color_err == '':
                call(['git', 'config', '--unset', 'color.status'])

                # unset may leave an empty section, remove it if it is
                section_count = literal_eval(check_output(['git', 'settings', 'list', '--local', '--count', color]))
                if section_count == 0:
                    call(['git', 'config', '--remove-section', 'color'])
            else:
                call(['git', 'config', 'color.status', color_status_out])

        if args.log_count != 0:
            log = check_output(['git', 'log', '-n', str(args.log_count), '--oneline', '--color={}'.format(color)])
            state += print_section("log", log, args.format)

        if args.reflog_count != 0:
            reflog = check_output(['git', 'reflog', '-n', str(args.reflog_count), '--color={}'.format(color)])
            state += print_section('reflog', reflog, args.format)

        if args.show_branches and (show_only_default_branch or not only_default_branch()):
            branches = check_output(['git', 'branch', '-vv', '--color={}'.format(color)])
            state += print_section('branches', branches, args.format)

        stashes = stashes = check_output(['git', 'stash', 'list', '--oneline', '--color={}'.format(color)])
        if args.show_stashes and (args.show_empty or len(stashes) > 0):
            state += print_section('stashes', stashes, args.format)

    state = state[:-1] # strip the extra trailing newline
    state_lines = len(state.splitlines())
    terminal_lines = literal_eval(check_output(['tput', 'lines']))
    if terminal_lines >= state_lines + 2: # one for the newline and one for the prompt
        print state
    else:
        echo = Popen(['echo', state], stdout=PIPE)
        call(['less', '-r'], stdin=echo.stdout)
        echo.wait()


if __name__ == "__main__":
    main()

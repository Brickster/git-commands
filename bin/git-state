#! /usr/bin/env python

import getopt
import re
import sys

from ast import literal_eval
from subprocess import call, check_output, PIPE, Popen
from utils.help import man
from utils.messages import version, error, usage, info

class colors:
    green = "\x1B[0;32m"
    no_color = "\x1B[0m"


def print_section(title, text=None, format="compact"):
    """Print a section."""

    section = "# {}{}{}".format(colors.green, title, colors.no_color) + '\n'

    if format == "pretty" and text is not None and len(text) > 0:
        # pretty print
        section += '\n'
        text = text.splitlines()
        for line in text:
            section += "    " + line + '\n'
        section += '\n'
    elif format == 'pretty':
        # there's no text but we still want some nicer formatting
        section += '\n'
    elif format == 'compact':
        section += text
    else:
        error("unknown format '{}'".format(format))

    return section


def get_options():
    """Return all options and long options."""

    # help options
    options = ["h", "v"]
    long_options = ["help", "version"]

    # status options
    options += ['s', 'S']
    long_options += ['status', 'no-status']

    # log options
    options += ["l:", "L"]
    long_options += ["log=", "no-log", "full-log"]

    # reflog options
    options += ['r:', 'R']
    long_options += ['reflog=', 'no-reflog', 'full-reflog']

    # branches options
    options += ['b', 'B']
    long_options += ['branches', 'no-branches']

    # stashes options
    options += ['t', 'T']
    long_options += ['stashes', 'no-stashes']

    # universal long options
    options += ["c", "C", "p", "f:", '-e', '-E']
    long_options += ["color", "no-color", "pretty", "format=", 'show-empty', 'no-show-empty']

    return ("".join(options), long_options)


def only_default_branch():
    """Determine whether the branches section only contains the default branch."""

    branches = check_output(['git', 'branch', '--no-color']).splitlines()

    if len(branches) > 1:
        return False

    default_branch = check_output(['git', 'settings', '-d', 'master', 'git-state.branches.default']).splitlines()[0]
    if re.match('\* {}'.format(default_branch), branches[0]) is not None:
        return True
    else:
        return False


def is_new_repository():
    """Determines whether a repository is empty."""

    log = Popen(['git', 'log', '--oneline', '-1'], stdout=PIPE, stderr=PIPE)
    log_out, log_err = log.communicate()

    return log_err != '' and log_err.splitlines()[0] == "fatal: bad default revision 'HEAD'"


def main(argv):

    # status defaults
    show_status = literal_eval(check_output(['git', 'settings', '-d', 'True', 'git-state.status.show']))

    # log defaults
    show_log = literal_eval(check_output(['git', 'settings', '-d', 'True', 'git-state.log.show']))
    log_count = literal_eval(check_output(['git', 'settings', '-d', '10', 'git-state.log.count']))

    # reflog defaults
    show_reflog = literal_eval(check_output(['git', 'settings', '-d', 'True', 'git-state.reflog.show']))
    reflog_count = literal_eval(check_output(['git', 'settings', '-d', '5', 'git-state.reflog.count']))

    # branches defaults
    show_branches = literal_eval(check_output(['git', 'settings', '-d', 'True', 'git-state.branches.show']))

    # stashes defaults
    show_stashes = literal_eval(check_output(['git', 'settings', '-d', 'True', 'git-state.stashes.show']))

    # general defaults
    show_only_default_branch = literal_eval(check_output(['git', 'settings', '-d', 'True', 'git-state.branches.show-only-default']))
    show_empty = literal_eval(check_output(['git', 'settings', '-d', 'False', 'git-state.show-empty']))
    print_format = check_output(['git', 'settings', '-d', 'compact', 'git-state.format']).splitlines()[0]
    color = check_output(['git', 'settings', '-d', 'always', 'color.ui']).splitlines()[0]

    try:
        opts, left_args = getopt.getopt(argv, *get_options())
    except getopt.GetoptError as e:
        error(e.msg, exit=False)
        usage(['git state [(-s|--status)] [(-S|--no-status)]',
            '          [(-l|--log) <count>] [(-L|--no-log)] [--full-log]',
            '          [(-c|--color)] [(-C|--no-color)]',
            '          [(-p|--pretty)] [(-f|--format) <format>]',
            '          [(-r|--reflog) <count>] [(-R|--no-reflog)] [--full-reflog]',
            '          [(-b|--branches)] [(-B|--no-branches)]',
            '          [(-t|--stashes)] [(-T|--no-stashes)]',
            '          [(-e|--show-empty)] [(-E|--no-show-empty)]',
            'git state (-h|--help)',
            'git state (-v|--version)'
        ])

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            man()
        elif opt in ('-v', '--version'):
            version('0.1.0')
        elif opt in ('-s', '--status'):
            show_status = True
        elif opt in ('-S', '--no-status'):
            show_status = False
        elif opt in ('-l', '--log'):
            show_log = True
            log_count = arg
        elif opt in ('-L', '--no-log'):
            show_log = False
            log_count = 0
        elif opt == '--full-log':
            show_log = True
            log_count = -1
        elif opt in ('-r', '--reflog'):
            show_reflog = True
            reflog_count = arg
        elif opt in ('-R', '--no-reflog'):
            show_reflog = False
            reflog_count = 0
        elif opt == '--full-reflog':
            show_reflog = True
            reflog_count = -1
        elif opt in ('-b', 'branches'):
            show_branches = True
        elif opt in ('-B', '--no-branches'):
            show_branches = False
        elif opt in ('-t', '--stashes'):
            show_stashes = True
        elif opt in ('-T', '--no-stashes'):
            show_stashes = False
        elif opt in ('-e', '--show-empty'):
            show_empty = True
        elif opt in ('-E', '--no-show-empty'):
            show_empty = False
        elif opt in ('-c', '--color'):
            color = "always"
        elif opt in ('-C', '--no-color'):
            color = "never"
            colors.green = colors.no_color
        elif opt in ('-f', '--format'):
            print_format = arg
        elif opt in ('-p', '--pretty'):
            print_format = "pretty"

    state = ''
    if is_new_repository():

        # make sure status will output ANSI codes
        # this must be done using config since status has no --color option
        status_color = Popen(['git', 'config', '--local', 'color.status'], stdout=PIPE, stderr=PIPE)
        status_color_out, status_color_err = status_color.communicate()
        call(['git', 'config', 'color.status', color])

        # check if status is empty
        status = check_output(['git', 'status', '--short'])
        if status == "":
            status = "Initial commit"

        title = 'status {}({}master{})'.format(colors.no_color, colors.green, colors.no_color)
        state += print_section(title, status, print_format)

        # reset color.status to its original setting
        if status_color_err == '':
            call(['git', 'config', '--unset', 'color.status'])

            # unset may leave an empty section, remove it if it is
            section_count = literal_eval(check_output(['git', 'settings', 'list', '--local', '--count', color]))
            if section_count == 0:
                call(['git', 'config', '--remove-section', 'color'])
        else:
            call(['git', 'config', 'color.status', color_status_out])

    else:
        # with open('/Users/z0018n6/Desktop/tmp.txt', 'w') as file:
        if show_status:

            # make sure status will output ANSI codes
            # this must be done using config since status has no --color option
            status_color = Popen(['git', 'config', '--local', 'color.status'], stdout=PIPE, stderr=PIPE)
            status_color_out, status_color_err = status_color.communicate()
            call(['git', 'config', 'color.status', color])

            status = check_output(['git', 'status', '--short', '--branch']).splitlines()
            status_title = 'status {}({})'.format(colors.no_color ,status.pop(0).lstrip('# '))
            status = '\n'.join(status)
            state += print_section(status_title, status, print_format)

            # reset color.status to its original setting
            if status_color_err == '':
                call(['git', 'config', '--unset', 'color.status'])

                # unset may leave an empty section, remove it if it is
                section_count = literal_eval(check_output(['git', 'settings', 'list', '--local', '--count', color]))
                if section_count == 0:
                    call(['git', 'config', '--remove-section', 'color'])
            else:
                call(['git', 'config', 'color.status', color_status_out])


        if show_log and log_count != 0:
            log = check_output(['git', 'log', '-n', str(log_count), '--oneline', '--color={}'.format(color)])
            state += print_section("log", log, print_format)

        if show_reflog and reflog_count != 0:
            reflog = check_output(['git', 'reflog', '-n', str(reflog_count), '--color={}'.format(color)])
            state += print_section('reflog', reflog, print_format)

        if show_branches and (show_only_default_branch or not only_default_branch()):
            branches = check_output(['git', 'branch', '-vv', '--color={}'.format(color)])
            state += print_section('branches', branches, print_format)

        stashes = stashes = check_output(['git', 'stash', 'list', '--oneline', '--color={}'.format(color)])
        if show_stashes and (show_empty or len(stashes) > 0):
            state += print_section('stashes', stashes, print_format)

    state = state[:-1] # strip the extra trailing newline
    state_lines = len(state.splitlines())
    terminal_lines = literal_eval(check_output(['tput', 'lines']))
    if terminal_lines >= state_lines + 2: # one for the newline and one for the prompt
        print state
    else:
        echo = Popen(['echo', state], stdout=PIPE)
        call(['less', '-r'], stdin=echo.stdout)
        echo.wait()


if __name__ == "__main__":
    main(sys.argv[1:])

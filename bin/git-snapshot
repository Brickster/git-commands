#! /bin/bash

STASH_ID_REGEX="^stash@\{([[:digit:]]+)\}.*$"
DROP_HASH_REGEX="^.*\(([[:xdigit:]]+)\)$"

function save
{
    message="$1"

    # get the last snapshot ID
    stashs=$(git stash list 2>&1)
    IFS=$'\n' read -rd '' -a stashs <<< "$stashs"
    max_stash_id=-1
    for stash in "${stashs[@]}"
    do
        regex="^.*snapshot\@\{([[:digit:]]+)\}.*$"
        if [[ $stash =~ $regex ]]; then
            if (( "$max_stash_id" < "${BASH_REMATCH[1]}" )); then
                max_stash_id="${BASH_REMATCH[1]}"
            fi
        fi
    done

    if [[ -z "$message" ]]; then
        # no message, use the last commit
        message=$(git log -1 --oneline)
    fi

    ((max_stash_id++))
    git stash save -u --quiet "snapshot@{$max_stash_id} $message" 
    git stash apply --quiet > /dev/null 2>&1 # apply won't shut up so swallow the output

    exit 0
}

#
# Redirects a snapshot subcommand to its stash counterpart
#
# $1: the subcommand to redirect to
# $2: the snapshot to show
#
function stash_redirect
{
    subcommand="$1"
    snapshot="$2"

    if [[ -z "$snapshot" ]]; then
        error "A snapshot must be specified using \"git snapshot $subcommand <snapshot>\""
    fi

    snapshots=$(git snapshot list 2>&1)
    IFS=$'\n' read -rd '' -a snapshots <<< "$snapshots"

    for stash in "${snapshots[@]}"; do
        if [[ $stash =~ ^.*"$snapshot".*$ ]]; then

            # get the snapshot's stash ID
            [[ $stash =~ $STASH_ID_REGEX ]]
            stash_count=${BASH_REMATCH[1]}

            git stash "$subcommand" stash@{$stash_count}
            exit 0
        fi
    done

    error "fatal: Log for 'snapshot' has no entry $snapshot."
    exit 1
}

#
# Drops a snapshot.
#
# $1: the snapshot to drop
#
function drop
{
    snapshot="$1"

    if [[ -z "$snapshot" ]]; then
        error 'A snapshot must be specified using "git snapshot drop <snapshot>"'
    fi

    snapshots=$(git snapshot list 2>&1)
    IFS=$'\n' read -rd '' -a snapshots <<< "$snapshots"

    for stash in "${snapshots[@]}"; do
        if [[ $stash =~ ^.*"$snapshot".*$ ]]; then

            # get the snapshot's stash ID
            [[ $stash =~ $STASH_ID_REGEX ]]
            stash_count=${BASH_REMATCH[1]}

            # drop the corresponding stash and get its hash
            drop_output=$(git stash drop stash@{$stash_count})
            [[ $drop_output =~ $DROP_HASH_REGEX ]]
            stash_hash=${BASH_REMATCH[1]}

            echo "Dropped $snapshot ($stash_hash)"
            exit 0
        fi
    done

    error "fatal: Log for 'snapshot' has no entry $snapshot."
    exit 1
}

#
# Echos text to strerr.
#
# $1: the text to echo
#
function error
{
    echo "$1" >&2
    exit 1
}

function usage_error
{
    error "usage: git snapshot [(-h|--help)]
   or: git snapshot save <message>
   or: git snapshot list
   or: git snapshot clear
   or: git snapshot drop <snapshot>
   or: git snapshot apply <snapshot>
   or: git snapshot pop <snapshot>"
}

#
# Shows git-snapshot man page.
#
function help
{
    man git-snapshot
    exit 0
}

#
# Clears all snapshots.
#
function clear
{
    stashs=$(git stash list 2>&1)
    IFS=$'\n' read -rd '' -a stashs <<< "$stashs"

    count=0
    total=${#stashs[@]}
    for stash in "${stashs[@]}"
    do
        if [[ $stash =~ ^.*snapshot\@\{[[:digit:]]+\}.*$ ]]; then
            git stash drop stash@{$count} --quiet
            clear # recurse
        fi
        ((count++))
    done

    exit 0
}

#
# Lists all snapshots.
#
function list
{
    stashs=$(git stash list 2>&1)
    IFS=$'\n' read -rd '' -a stashs <<< "$stashs"

    count=0
    for stash in "${stashs[@]}"
    do
        if [[ $stash =~ ^.*snapshot\@\{[[:digit:]]+\}.*$ ]]; then
            echo "$stash"
        fi
    done
    exit 0
}

if [[ "$1" =~ ^(clear|list)$ ]]; then
    "$1"
elif [[ "$1" == "drop" ]]; then
    drop "$2"
elif [[ "$1" =~ ^(apply|pop|show)$ ]]; then
    stash_redirect "$1" "$2"
elif [[ "$1" =~ ^(save)$ ]]; then
    args=("$@") # so I can split the input
    args=("${args[@]:1}")
    save "$args"
elif [[ ! -z "$1" ]] && [[ ! "$1" =~ ^-.*$ ]]; then
    usage_error
fi

while getopts ":h-:" opt; do
    case $opt in
        -)
            case "${OPTARG}" in
                help)   help;;
                *)      error "Unimplemented option --${OPTARG}";;
            esac
            ;;
        h)  help;;
        \?) error "Invalid option: -$OPTARG";;
        :)  error "Option -$OPTARG requires an argument.";;
        *)  error "Unimplemented option: -$OPTARG";;
    esac
done

save

#! /bin/bash

STASH_ID_REGEX="^stash@\{([[:digit:]]+)\}.*$"
DROP_HASH_REGEX="^.*\(([[:xdigit:]]+)\)$"

function main
{
    message=
    while getopts ":hm:-:" opt; do
        case $opt in
            -)
                case "${OPTARG}" in
                    message)
                        message="${!OPTIND}"
                        OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    help)
                        help
                        ;;
                    *)
                        error "Unimplemented option --${OPTARG}"
                        ;;
                esac
                ;;
            m)  message="$OPTARG";;
            h)  help;;
            \?) error "Invalid option: -$OPTARG";;
            :)  error "Option -$OPTARG requires an argument.";;
            *)  error "Unimplemented option: -$OPTARG";;
        esac
    done

    # get the last snapshot ID
    stashs=$(git stash list 2>&1)
    IFS=$'\n' read -rd '' -a stashs <<< "$stashs"
    max_stash_id=-1
    for stash in "${stashs[@]}"
    do
        regex="^.*snapshot\@\{([[:digit:]]+)\}.*$"
        if [[ $stash =~ $regex ]]; then
            if (( "$max_stash_id" < "${BASH_REMATCH[1]}" )); then
                max_stash_id="${BASH_REMATCH[1]}"
            fi
        fi
    done

    if [[ -z "$message" ]]; then
        # no message, use the last commit
        message=$(git log -1 --oneline)
    fi

    ((max_stash_id++))
    git stash save -u --quiet "snapshot@{$max_stash_id} $message" 
    git stash apply --quiet > /dev/null 2>&1 # apply won't shut up so swallow the output
}

#
# Pop a snapshot
#
# $1: the snapshot to pop
#
function pop
{
    snapshot="$1"

    if [[ -z "$snapshot" ]]; then
        error 'A snapshot must be specified using "git snapshot pop <snapshot>"'
    fi

    snapshots=$(git snapshot list 2>&1)
    IFS=$'\n' read -rd '' -a snapshots <<< "$snapshots"

    for stash in "${snapshots[@]}"; do
        if [[ $stash =~ ^.*"$snapshot".*$ ]]; then

            # get the snapshot's stash ID
            [[ $stash =~ $STASH_ID_REGEX ]]
            stash_count=${BASH_REMATCH[1]}

            git stash pop stash@{$stash_count}
            exit 0
        fi
    done

    error "fatal: Log for 'snapshot' only has no entry $snapshot."
    exit 1
}

#
# Apply a snapshot
#
# $1: the snapshot to apply
#
function apply
{
    snapshot="$1"

    if [[ -z "$snapshot" ]]; then
        error 'A snapshot must be specified using "git snapshot apply <snapshot>"'
    fi

    snapshots=$(git snapshot list 2>&1)
    IFS=$'\n' read -rd '' -a snapshots <<< "$snapshots"

    for stash in "${snapshots[@]}"; do
        if [[ $stash =~ ^.*"$snapshot".*$ ]]; then

            # get the snapshot's stash ID
            [[ $stash =~ $STASH_ID_REGEX ]]
            stash_count=${BASH_REMATCH[1]}

            git stash apply stash@{$stash_count}
            exit 0
        fi
    done

    error "fatal: Log for 'snapshot' only has no entry $snapshot."
    exit 1
}

#
# Drops a snapshot.
#
# $1: the snapshot to drop
#
function drop
{
    snapshot="$1"

    if [[ -z "$snapshot" ]]; then
        error 'A snapshot must be specified using "git snapshot drop <snapshot>"'
    fi

    snapshots=$(git snapshot list 2>&1)
    IFS=$'\n' read -rd '' -a snapshots <<< "$snapshots"

    for stash in "${snapshots[@]}"; do
        if [[ $stash =~ ^.*"$snapshot".*$ ]]; then

            # get the snapshot's stash ID
            [[ $stash =~ $STASH_ID_REGEX ]]
            stash_count=${BASH_REMATCH[1]}

            # drop the corresponding stash and get its hash
            drop_output=$(git stash drop stash@{$stash_count})
            [[ $drop_output =~ $DROP_HASH_REGEX ]]
            stash_hash=${BASH_REMATCH[1]}

            echo "Dropped $snapshot ($stash_hash)"
            exit 0
        fi
    done

    error "fatal: Log for 'snapshot' only has no entry $snapshot."
    exit 1
}

#
# Echos text to strerr.
#
# $1: the text to echo
#
function error
{
    echo "$1" >&2
    exit 1
}

#
# Shows git-snapshot man page.
#
function help
{
    man git-snapshot
    exit 0
}

#
# Clears all snapshots.
#
function clear
{
    stashs=$(git stash list 2>&1)
    IFS=$'\n' read -rd '' -a stashs <<< "$stashs"

    count=0
    total=${#stashs[@]}
    for stash in "${stashs[@]}"
    do
        if [[ $stash =~ ^.*snapshot\@\{[[:digit:]]+\}.*$ ]]; then
            git stash drop stash@{$count} --quiet
            clear # recurse
        fi
        ((count++))
    done

    exit 0
}

#
# Lists all snapshots.
#
function list
{
    stashs=$(git stash list 2>&1)
    IFS=$'\n' read -rd '' -a stashs <<< "$stashs"

    count=0
    for stash in "${stashs[@]}"
    do
        if [[ $stash =~ ^.*snapshot\@\{[[:digit:]]+\}.*$ ]]; then
            echo "$stash"
        fi
    done
    exit 0
}

if [[ "$1" =~ ^(clear|list)$ ]]; then
    "$1"
elif [[ "$1" =~ ^(drop|apply|pop)$ ]]; then
    "$1" "$2"
fi
main "$@"
